``//__init__.py: #py

``import``

``identifier class``
``amount class``
``idable class``
``sample class``
``patient class``
``finding class``
``user class``

``rec``
``booleanrec``
``numberrec``
``stringrec``
``daterec``
``catalogrec``
``multirec``

``

Identifier holds an identifier.

``/identifier class:
class Identifier:
    ``init``
``

__init__ initializes an identifier.

``/identifier class/init:
    def __init__(self, id=None, code:str=None):
        ``.``
``

remember the arguments.

``
        self.id = id
        self.code = code
``

Amount holds an amount.

``/amount class:
class Amount:
    ``init``
    ``__str__``
``

__init__ initializes an amount.

``/amount class/init:
    def __init__(self, value:float=None, unit:str=None):
        ``.``
``

remember the arguments.

``
        self.value = value
        self.unit = unit
``

__str__ gives the value and unit in human-readable format.

``/amount class/__str__:
    def __str__(self):
        return str(self.value) + " " + self.unit
``

Idable holds a list of identifiers with idcontainer codes and
remembers which is the main idc code.

``/idable class:
class Idable:
    ``init``
    ``identifier``
    ``id``
    ``set_id``
    ``iddict``    
    ``__str__``
``

__init__ initializes an Idable from a list of Identifiers and a
mainidc string.

``/idable class/init:
    def __init__(self, ids:list=None, mainidc:str=None, id=None, code:str=None):
        self.ids = ids
        if self.ids is None:
            self.ids = []
        self.mainidc = mainidc
``

id and code give a shortcut for creating a list.

``
        if id is not None:
            self.ids.append(Identifier(id=id, code=code))
``

identifier returns the Identifier for the given code, if no code
given, the Identifier for the main idc returned.


``/idable class/identifier:
    def identifier(self, code:str=None) -> Identifier:
        ``.``
``

take the standard sampleid container if no code is passed.

``
        if code == None:
            code = self.mainidc
``

iterate the identifiers, if its code matches self.sidc, return.

``
        for identifier in self.ids:
            if identifier.code == code:
                return identifier
``


id returns the id value for the given code, if no code
given, the id value for the main idc is returned.


``/idable class/id:
    def id(self, code:str=None) -> str:
        if self.identifier(code) is not None:
            return self.identifier(code).id
        return None
``

``/idable class/set_id:
    def set_id(self, code:str=None, id:str=None):
        ``.``
``

find the identifier, else create it.

``
        for identifier in self.ids:
            if identifier.code == code:
                identifier.id = id
                return
``

if not set until now, create it.

``
        self.ids.append( Idable(id=id, code=code) )
``

__str__ gives a human readable representation of Idable, here the
id string.

``/idable class/__str__:
    def __str__(self):
        if self.id() is not None:
            return self.id()
        return ""
``

iddict returns a copy of the __dict__ holding the given ids at the
root level of the dict in addition to the classes attributes.  if no
ids are given, all ids taken.  the ids and mainidc fields are cleared,
exept when keep is true. if iddict is called on an inheriting class
(e.g. Sample) the dict gives the inheriting classes attributes.

``/idable class/iddict:
    def iddict(self, *idcs):
        ``.``
``

the first asterix before idcs indicates that any number of idcs can be
passed.

make a copy of the dict holding all attributes.

``
        d = self.__dict__.copy()
``

if no specific idcontainers are given, take all.

``
        if idcs == None or len(idcs) == 0:
            idcs = [id.code for id in self.ids]
``

put the ids in the root level of the dict.

``
        for idc in idcs:
            d[idc] = self.id(idc)
``

delete the ids and mainidc field from dict.

``
        del d["ids"]
        del d["mainidc"]
``

return the dict.

``
        return d
``
        


Sample holds a sample.

``/sample class:
class Sample(Idable):
    ``var``
    ``init``
    ``default``
    ``sampleid``
    ``__getstate__``
``

declare the variables.

appointment holds sample's visit (appointmentnumber in db).

``/sample class/var:
    appointment:str = None
``


category holds the sample's category, MASTER, ALIQUOTGROUP or
DERIVED. called dtype in db.

``
    category:str = None
``

concentration holds the sample's concentration.

``
    concentration=None
``

derivaldate holds the sample's derival date (when it was derived as an
aliquot).

``
    derivaldate:datetime=None
``

receiptdate holds the date of the samples entry into the
laboratory. called receiptdate in the db.

``
    receiptdate:datetime=None
``

first_repositiondate holds the sample's first repositioning date. this
can't be changed after it was first written (by what? db?
fhir?). since it doesn't change like the repositiondate field, but
stays on the first time the sample was stored, it should hold the date
the sample was frozen.

``
    first_repositiondate:datetime=None
``


initialamount holds the sample's initial amount.

``
    initialamount:Amount=None
``

locationname holds the last part of the locationpath, the rack name.

``
    locationname:str=None
``

locationpath holds the sample's locationpath.

``
    locationpath:str=None
``

orga holds the sample's organization unit. called orgunit in the db.

``
    orga:str = None
``

parent holds this samples parent as Idable with potentially multiple
identifiers (oid, sampleid if there). oids are needed to keep track of
aliquotgroups.

``
    parent:Idable=None 
``

patient references the patient as Idable.

``
    patient:Idable = None
``

project holds?

``
    project:str = None
``

receptacle holds the sample's receptacle. called receptable in the db.

``
    receptacle:str=None
``

restamount holds the sample's rest amount. in db fields amountrest and restunit.

``
    restamount:Amount=None
``

samplingdate holds the date when the sample was extracted from the patient.

``
    samplingdate:datetime=None
``

secondprocessing holds the code of the second centrifugation.

``
    secondprocessing:str=None
``

secondprocessingdate holds the date of the second centrifugation.

``
    secondprocessingdate:datetime=None
``

stockprocessing holds the code of the first centrifugation.

``
    stockprocessing:str=None
``

secondprocessing holds the date of the first centrifugation.

``
    stockprocessingdate:datetime=None
``

repositiondate holds the date of the sample's latest repositioning (umlagern). 

``
    repositiondate:datetime=None
``

trial holds the trial code.

``
    trial:str=None
``

type holds the code of the sample's type/material (whole blood, EDTA,
liquor, etc). called sampletype in db.

``
    type:str=None
``

xposition holds the sample's x position on the rack.

``
    xposition:int=None
``

yposition holds the samples y position in the db.

``
    yposition:int=None
``

import.

``/import:
from datetime import datetime
``

__init__ initializes a sample.

``/sample class/init:
    def __init__(
         self,
         appointment:str=None,
         category:str=None,
         cxxkitid:str=None,
         concentration=None, # str?
         derivaldate:datetime=None,
         first_repositiondate:datetime=None,
         ids:list=None, # of Identifier         
         initialamount:Amount=None,
         kitid:str=None,
         locationpath:str=None,
         locationname:str=None,
         orga:str=None,
         parent:Idable=None,
         patient:Idable=None,
         project:str=None,
         receptacle:str=None, 
         restamount:Amount=None,
         samplingdate:datetime=None,
         secondprocessing:str=None,
         secondprocessingdate:datetime=None,         
         stockprocessing:str=None,
         stockprocessingdate:datetime=None,         
         receiptdate:datetime=None,         
         repositiondate:datetime=None,
         sidc:str=None,
         trial:str=None,
         type:str=None,
         xposition:int=None, 
         yposition:int=None
         ):
        ``.``
``

call super.

``
        Idable.__init__(self, ids, sidc)
``

fill in the parameters.

``
        self.appointment = appointment
        self.category = category
        self.cxxkitid = cxxkitid
        self.concentration = concentration
        self.derivaldate = derivaldate
        self.receiptdate = receiptdate
        self.first_repositiondate = first_repositiondate
        self.initialamount = initialamount
        self.kitid = kitid
        self.locationpath = locationpath
        self.locationname = locationname
        self.orga = orga
        self.parent = parent
        self.patient = patient
        self.project = project
        self.receptacle = receptacle
        self.repositiondate = repositiondate
        self.restamount = restamount
        self.secondprocessing = secondprocessing
        self.secondprocessingdate = secondprocessingdate        
        self.stockprocessing = stockprocessing
        self.stockprocessingdate = stockprocessingdate        
        self.samplingdate = samplingdate        
        self.trial = trial
        self.type = type
        self.xposition = xposition
        self.yposition = yposition
``

default returns the json dict.

``/sample class/default:
    def default(self, o):
        return o.__dict__
``

sampleid is a shorthand to get the sampleid so it isn't buried in a
dict when displaying the object as json.

``/sample class/sampleid:
    @property
    def sampleid(self):
        return "bla" # self.get_id()
``

__getstate__ returns what gets jsonpickled. include sampleid and
patientid in root level, for quicker access.

``/sample class/__getstate__:
    def __getstate__(self):
        state = self.__dict__.copy() # is this slow?
        state[sampleid] = self.id()
        state[patientid] = self.patient.id() if self.patient else None
        return state
``


Patient holds a patient.

``/patient class:
class Patient(Idable):
    ``init``
    ``__getstate__``
``

__init__ initializes a patient.

``/patient class/init:
    def __init__(
      self,
      ids:list=None,
      orga:str=None,
      pidc:str=None
    ):
        ``.``
``

call super.

``
        Idable.__init__(self, ids, pidc)
``


remember the paramenters.

``
        self.orga = orga
``

__getstate__ returns what gets jsonpickled. include the patientid at the root level, for quicker access.

``/patient class/__getstate__:
    def __getstate__(self):
        state = self.__dict__.copy() # is this slow?
        state[patientid] = self.id()
        return state
``


``/finding class:
class Finding:
    ``var``
    ``init``
``

method holds the finding's method (messprofil).

``/finding class/var:
    method:str=None
``

findingdate holds the finding's finding date.

``
    findingdate:datetime=None
``

methodname holds the finding's method name. (why extra?).

``
    methodname:str=None
``

patient references the patient this finding belongs to.

``
    patient:Idable=None
``

recs holds a list of recorded values for this finding.

``
    recs:map={} # of Rec, by code
``

sample references the sample Idable this finding belongs to.

``
    sample:Idable
``

sender holds the sender.

``
    sender:str=None
``

__init__ initializes a finding.

``/finding class/init:
    def __init__(
        self,
        findingdate:datetime=None,
        method:str=None,
        methodname:str=None,
        patient:Idable=None,        
        recs:map={}, # of Rec, by code
        sample:Idable=None,
        sender:str=None,
    ):
        ``.``
``

remember the arguments.

``
        self.findingdate = findingdate
        self.method = method
        self.methodname = methodname
        self.patient = patient
        self.recs = recs
        self.sample = sample
        self.sender = sender
``

User holds a cxx user.

``/user class:
class User:
    ``init``
``

__init__ inits a User.

``/user class/init:
    def __init__(self,
      lastlogin:datetime=None,
      email:str=None,
      username:str=None):
        ``.``
``

remember the arguments.

``
        self.lastlogin = lastlogin
        self.email = email
        self.username = username
``

Rec is the base class for recorded values like StringRec, etc.

``/rec:
class Rec:
    ``var``
    ``init``
``

hold method (messprofil) and labval (messparameter) codes?

``/rec/var:
    method:str = None
    labval:str = None
``

type holds the laborvalue's type (dtype in the db). it can be:

STRING (e.g. RNA_CONCENTRATION_NG_L)
LONGSTRING (e.g. FILES)
CATALOG (e.g. PATHOGEN2. references the catalog used via the custom_catalog field. choicetype SELECTONE or SELECTMANY)
ENUMERATION (e.g. REASONNOSAMPLES2. from kontrolliertes vokabular, the labvalenum_usageentry field specifies which kontrolliertes vokabular can be used. choicetype SELECTONE or SELECTMANY)
BOOLEAN (e.g. IS_REST)
OPTIONGROUP (e.g. NSN_INF_MODUL. checkboxes, from kontrolliertes vokabular, also via labvalenum? choicetype SELECTONE or SELECTMANY)
DATE (e.g. TIMEPOOL)
LONGDATE (e.g. PLANNEDSAMPLINGDATE_1. what's the difference between DATE and LONGDATE?)
DECIMAL (e.g. NUM_BAL_SPUELVOLUMEN. is this float?)
INTEGER (e.g. URNCT)

``
    type:str = None
``

__init__ inits a Rec.

``/rec/init:
    def __init__(self, method:str=None, labval:str=None):
        self.labval = labval
``


BooleanRec holds a BOOLEAN rec.

``/booleanrec:
class BooleanRec(Rec):
    ``var``
    ``init``
``

value is the boolean value for the rec.

``/booleanrec/var:
    value:bool = None
``

__init__ inits a BooleanRec.

``/booleanrec/init:
    def __init__(self, method:str=None, labval:str=None, value:bool=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
``

NumberRec holds a DECIMAL rec. (what about INTEGER?)

``/numberrec:
class NumberRec(Rec):
    ``var``
    ``init``
``

value is the number value for the rec.

is float ok for all?

``/numberrec/var:
    value:float = None
``

unit is the unit via the laborvalue.

``
    unit:str = None
``

__init__ inits a NumberRec.

``/numberrec/init:
    def __init__(self, method:str=None, labval:str=None, value:float=None, unit:str=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
        self.unit = unit
``


StringRec holds a STRING or LONGSTRING rec.

``/stringrec:
class StringRec(Rec):
    ``var``
    ``init``
``

value is the string value for the rec.

``/stringrec/var:
    value:str = None
``

__init__ inits a StringRec.

``/stringrec/init:
    def __init__(self, method:str=None, labval:str=None, value:str=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
``

DateRec holds a DATE or LONGDATE rec.

``/daterec:
class DateRec(Rec):
    ``var``
    ``init``
``

value is the date value for the rec.

``/daterec/var:
    value:datetime = None
``

__init__ inits a DateRec.

``/daterec/init:
    def __init__(self, method:str=None, labval:str=None, value:datetime=None):
        Rec.__init__(self, method=method, labval=labval)
        self.value = value
``


MultiRec holds an OPTIONGROUP or ENUMERATION rec.

``/multirec:
class MultiRec(Rec):
    ``var``
    ``init``
``

values holds the usage entry (kontrolliertes vokabular) codes.

``/multirec/var:
    values:str = None
``

__init__ inits a MultiRec.

``/multirec/init:
    def __init__(self, method:str=None, labval:str=None, values:list=None):
        Rec.__init__(self, method=method, labval=labval)
        self.values = values
``


CatalogRec holds a CATALOG rec.

``/catalogrec:
class CatalogRec(Rec):
    ``var``
    ``init``
``

values holds the catalog entry codes.

``/catalogrec/var:
    values:str = None
``

catalog holds the catalog code.

``
    catalog:str = None
``

__init__ inits a CatalogRec.

``/catalogrec/init:
    def __init__(self, method:str=None, labval:str=None, values:list=None, catalog:str=None):
        Rec.__init__(self, method=method, labval=labval)
        self.values = values
        self.catalog = catalog
``


